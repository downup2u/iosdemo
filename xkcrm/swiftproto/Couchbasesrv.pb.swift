// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
//import ProtocolBuffers

struct CouchbasesrvRoot {
  static var sharedInstance : CouchbasesrvRoot {
   struct Static {
       static let instance : CouchbasesrvRoot = CouchbasesrvRoot()
   }
   return Static.instance
  }
  var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  func registerAllExtensions(registry:ExtensionRegistry) {
  }
}



//Enum type declaration start 

enum EnLcbOperation:Int32 {
  case LcbStore = 1
  case LcbGet = 2
  case LcbRemove = 3
  case LcbHttprequest = 4
  case LcbUserdefine = 100

  static func IsValidValue(value:EnLcbOperation) ->Bool {
    switch value {
      case .LcbStore, .LcbGet, .LcbRemove, .LcbHttprequest, .LcbUserdefine:
        return true;
      default:
        return false;
    }
  }
}



//Enum type declaration end 

func == (lhs: DBOperationReq, rhs: DBOperationReq) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEnlcboperation == rhs.hasEnlcboperation) && (!lhs.hasEnlcboperation || lhs.enlcboperation == rhs.enlcboperation)
  fieldCheck = fieldCheck && (lhs.hasDockey == rhs.hasDockey) && (!lhs.hasDockey || lhs.dockey == rhs.dockey)
  fieldCheck = fieldCheck && (lhs.hasDoctxt == rhs.hasDoctxt) && (!lhs.hasDoctxt || lhs.doctxt == rhs.doctxt)
  fieldCheck = fieldCheck && (lhs.hasEnlcbstorecmd == rhs.hasEnlcbstorecmd) && (!lhs.hasEnlcbstorecmd || lhs.enlcbstorecmd == rhs.enlcbstorecmd)
  fieldCheck = fieldCheck && (lhs.hasPath == rhs.hasPath) && (!lhs.hasPath || lhs.path == rhs.path)
  fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
  fieldCheck = fieldCheck && (lhs.hasContenttype == rhs.hasContenttype) && (!lhs.hasContenttype || lhs.contenttype == rhs.contenttype)
  fieldCheck = fieldCheck && (lhs.hasEnhttpmethod == rhs.hasEnhttpmethod) && (!lhs.hasEnhttpmethod || lhs.enhttpmethod == rhs.enhttpmethod)
  fieldCheck = fieldCheck && (lhs.hasEnreqtype == rhs.hasEnreqtype) && (!lhs.hasEnreqtype || lhs.enreqtype == rhs.enreqtype)
  fieldCheck = fieldCheck && (lhs.hasUuidstring == rhs.hasUuidstring) && (!lhs.hasUuidstring || lhs.uuidstring == rhs.uuidstring)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

func == (lhs: DBOperationReply, rhs: DBOperationReply) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasEnlcboperation == rhs.hasEnlcboperation) && (!lhs.hasEnlcboperation || lhs.enlcboperation == rhs.enlcboperation)
  fieldCheck = fieldCheck && (lhs.hasIssuc == rhs.hasIssuc) && (!lhs.hasIssuc || lhs.issuc == rhs.issuc)
  fieldCheck = fieldCheck && (lhs.hasErr == rhs.hasErr) && (!lhs.hasErr || lhs.err == rhs.err)
  fieldCheck = fieldCheck && (lhs.hasErrdesc == rhs.hasErrdesc) && (!lhs.hasErrdesc || lhs.errdesc == rhs.errdesc)
  fieldCheck = fieldCheck && (lhs.hasDockey == rhs.hasDockey) && (!lhs.hasDockey || lhs.dockey == rhs.dockey)
  fieldCheck = fieldCheck && (lhs.hasDoctxt == rhs.hasDoctxt) && (!lhs.hasDoctxt || lhs.doctxt == rhs.doctxt)
  fieldCheck = fieldCheck && (lhs.hasHttppath == rhs.hasHttppath) && (!lhs.hasHttppath || lhs.httppath == rhs.httppath)
  fieldCheck = fieldCheck && (lhs.hasHttpheaders == rhs.hasHttpheaders) && (!lhs.hasHttpheaders || lhs.httpheaders == rhs.httpheaders)
  fieldCheck = fieldCheck && (lhs.hasHttpjsonresult == rhs.hasHttpjsonresult) && (!lhs.hasHttpjsonresult || lhs.httpjsonresult == rhs.httpjsonresult)
  fieldCheck = fieldCheck && (lhs.hasUuidstring == rhs.hasUuidstring) && (!lhs.hasUuidstring || lhs.uuidstring == rhs.uuidstring)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final public class DBOperationReq : GeneratedMessage {


    //Enum type declaration start 

    enum EnLcbStorageT:Int32 {
      case LcbAdd = 1
      case LcbReplace = 2
      case LcbSet = 3
      case LcbAppend = 4
      case LcbPrepend = 5

      static func IsValidValue(value:EnLcbStorageT) ->Bool {
        switch value {
          case .LcbAdd, .LcbReplace, .LcbSet, .LcbAppend, .LcbPrepend:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 



    //Enum type declaration start 

    enum EnHttpMothod:Int32 {
      case LcbHttpMethodGet = 0
      case LcbHttpMethodPost = 1
      case LcbHttpMethodPut = 2
      case LcbHttpMethodDelete = 3
      case LcbHttpMethodMax = 4

      static func IsValidValue(value:EnHttpMothod) ->Bool {
        switch value {
          case .LcbHttpMethodGet, .LcbHttpMethodPost, .LcbHttpMethodPut, .LcbHttpMethodDelete, .LcbHttpMethodMax:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 



    //Enum type declaration start 

    enum EnReqType:Int32 {
      case LcbHttpTypeView = 0
      case LcbHttpTypeManagement = 1
      case LcbHttpTypeRaw = 2
      case LcbHttpTypeMax = 3

      static func IsValidValue(value:EnReqType) ->Bool {
        switch value {
          case .LcbHttpTypeView, .LcbHttpTypeManagement, .LcbHttpTypeRaw, .LcbHttpTypeMax:
            return true;
          default:
            return false;
        }
      }
    }



    //Enum type declaration end 

  private(set) var enlcboperation:EnLcbOperation = EnLcbOperation.LcbStore
  private(set) var hasEnlcboperation:Bool = false
  private(set) var hasDockey:Bool = false
  private(set) var dockey:String = ""

  private(set) var hasDoctxt:Bool = false
  private(set) var doctxt:String = ""

  private(set) var enlcbstorecmd:DBOperationReq.EnLcbStorageT = DBOperationReq.EnLcbStorageT.LcbAdd
  private(set) var hasEnlcbstorecmd:Bool = false
  private(set) var hasPath:Bool = false
  private(set) var path:String = ""

  private(set) var hasBody:Bool = false
  private(set) var body:String = ""

  private(set) var hasContenttype:Bool = false
  private(set) var contenttype:String = ""

  private(set) var enhttpmethod:DBOperationReq.EnHttpMothod = DBOperationReq.EnHttpMothod.LcbHttpMethodGet
  private(set) var hasEnhttpmethod:Bool = false
  private(set) var enreqtype:DBOperationReq.EnReqType = DBOperationReq.EnReqType.LcbHttpTypeView
  private(set) var hasEnreqtype:Bool = false
  private(set) var hasUuidstring:Bool = false
  private(set) var uuidstring:String = ""

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasEnlcboperation {
      output.writeEnum(1, value:enlcboperation.rawValue)
    }
    if hasDockey {
      output.writeString(11, value:dockey)
    }
    if hasDoctxt {
      output.writeString(12, value:doctxt)
    }
    if hasEnlcbstorecmd {
      output.writeEnum(13, value:enlcbstorecmd.rawValue)
    }
    if hasPath {
      output.writeString(21, value:path)
    }
    if hasBody {
      output.writeString(22, value:body)
    }
    if hasContenttype {
      output.writeString(23, value:contenttype)
    }
    if hasEnhttpmethod {
      output.writeEnum(24, value:enhttpmethod.rawValue)
    }
    if hasEnreqtype {
      output.writeEnum(25, value:enreqtype.rawValue)
    }
    if hasUuidstring {
      output.writeString(100, value:uuidstring)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if (hasEnlcboperation) {
      size += WireFormat.computeEnumSize(1, value:enlcboperation.rawValue)
    }
    if hasDockey {
      size += WireFormat.computeStringSize(11, value:dockey)
    }
    if hasDoctxt {
      size += WireFormat.computeStringSize(12, value:doctxt)
    }
    if (hasEnlcbstorecmd) {
      size += WireFormat.computeEnumSize(13, value:enlcbstorecmd.rawValue)
    }
    if hasPath {
      size += WireFormat.computeStringSize(21, value:path)
    }
    if hasBody {
      size += WireFormat.computeStringSize(22, value:body)
    }
    if hasContenttype {
      size += WireFormat.computeStringSize(23, value:contenttype)
    }
    if (hasEnhttpmethod) {
      size += WireFormat.computeEnumSize(24, value:enhttpmethod.rawValue)
    }
    if (hasEnreqtype) {
      size += WireFormat.computeEnumSize(25, value:enreqtype.rawValue)
    }
    if hasUuidstring {
      size += WireFormat.computeStringSize(100, value:uuidstring)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> DBOperationReq {
    return DBOperationReq.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> DBOperationReq {
    return DBOperationReq.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> DBOperationReq {
    return DBOperationReq.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->DBOperationReq {
    return DBOperationReq.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> DBOperationReq {
    return DBOperationReq.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DBOperationReq {
    return DBOperationReq.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> DBOperationReqBuilder {
    return DBOperationReqBuilder()
  }
  class func builderWithPrototype(prototype:DBOperationReq) -> DBOperationReqBuilder {
    return DBOperationReq.builder().mergeFrom(prototype)
  }
  func builder() -> DBOperationReqBuilder {
    return DBOperationReq.builder()
  }
  func toBuilder() -> DBOperationReqBuilder {
    return DBOperationReq.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if (hasEnlcboperation) {
      output += "\(indent) enlcboperation: \(enlcboperation.rawValue)\n"
    }
    if hasDockey {
      output += "\(indent) dockey: \(dockey) \n"
    }
    if hasDoctxt {
      output += "\(indent) doctxt: \(doctxt) \n"
    }
    if (hasEnlcbstorecmd) {
      output += "\(indent) enlcbstorecmd: \(enlcbstorecmd.rawValue)\n"
    }
    if hasPath {
      output += "\(indent) path: \(path) \n"
    }
    if hasBody {
      output += "\(indent) body: \(body) \n"
    }
    if hasContenttype {
      output += "\(indent) contenttype: \(contenttype) \n"
    }
    if (hasEnhttpmethod) {
      output += "\(indent) enhttpmethod: \(enhttpmethod.rawValue)\n"
    }
    if (hasEnreqtype) {
      output += "\(indent) enreqtype: \(enreqtype.rawValue)\n"
    }
    if hasUuidstring {
      output += "\(indent) uuidstring: \(uuidstring) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasEnlcboperation {
             hashCode = (hashCode &* 31) &+ Int(enlcboperation.rawValue)
          }
          if hasDockey {
             hashCode = (hashCode &* 31) &+ dockey.hashValue
          }
          if hasDoctxt {
             hashCode = (hashCode &* 31) &+ doctxt.hashValue
          }
          if hasEnlcbstorecmd {
             hashCode = (hashCode &* 31) &+ Int(enlcbstorecmd.rawValue)
          }
          if hasPath {
             hashCode = (hashCode &* 31) &+ path.hashValue
          }
          if hasBody {
             hashCode = (hashCode &* 31) &+ body.hashValue
          }
          if hasContenttype {
             hashCode = (hashCode &* 31) &+ contenttype.hashValue
          }
          if hasEnhttpmethod {
             hashCode = (hashCode &* 31) &+ Int(enhttpmethod.rawValue)
          }
          if hasEnreqtype {
             hashCode = (hashCode &* 31) &+ Int(enreqtype.rawValue)
          }
          if hasUuidstring {
             hashCode = (hashCode &* 31) &+ uuidstring.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DBOperationReq"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DBOperationReq.self
  }


  //Meta information declaration end

}

final class DBOperationReqBuilder : GeneratedMessageBuilder {
  private var builderResult:DBOperationReq

  required override init () {
     builderResult = DBOperationReq()
     super.init()
  }
    var hasEnlcboperation:Bool{
        get {
            return builderResult.hasEnlcboperation
        }
    }
    var enlcboperation:EnLcbOperation {
        get {
            return builderResult.enlcboperation
        }
        set (value) {
            builderResult.hasEnlcboperation = true
            builderResult.enlcboperation = value
        }
    }
    func clearEnlcboperation() -> DBOperationReqBuilder {
       builderResult.hasEnlcboperation = false
       builderResult.enlcboperation = .LcbStore
       return self
    }
  var hasDockey:Bool {
       get {
            return builderResult.hasDockey
       }
  }
  var dockey:String {
       get {
            return builderResult.dockey
       }
       set (value) {
           builderResult.hasDockey = true
           builderResult.dockey = value
       }
  }
  func clearDockey() -> DBOperationReqBuilder{
       builderResult.hasDockey = false
       builderResult.dockey = ""
       return self
  }
  var hasDoctxt:Bool {
       get {
            return builderResult.hasDoctxt
       }
  }
  var doctxt:String {
       get {
            return builderResult.doctxt
       }
       set (value) {
           builderResult.hasDoctxt = true
           builderResult.doctxt = value
       }
  }
  func clearDoctxt() -> DBOperationReqBuilder{
       builderResult.hasDoctxt = false
       builderResult.doctxt = ""
       return self
  }
    var hasEnlcbstorecmd:Bool{
        get {
            return builderResult.hasEnlcbstorecmd
        }
    }
    var enlcbstorecmd:DBOperationReq.EnLcbStorageT {
        get {
            return builderResult.enlcbstorecmd
        }
        set (value) {
            builderResult.hasEnlcbstorecmd = true
            builderResult.enlcbstorecmd = value
        }
    }
    func clearEnlcbstorecmd() -> DBOperationReqBuilder {
       builderResult.hasEnlcbstorecmd = false
       builderResult.enlcbstorecmd = .LcbAdd
       return self
    }
  var hasPath:Bool {
       get {
            return builderResult.hasPath
       }
  }
  var path:String {
       get {
            return builderResult.path
       }
       set (value) {
           builderResult.hasPath = true
           builderResult.path = value
       }
  }
  func clearPath() -> DBOperationReqBuilder{
       builderResult.hasPath = false
       builderResult.path = ""
       return self
  }
  var hasBody:Bool {
       get {
            return builderResult.hasBody
       }
  }
  var body:String {
       get {
            return builderResult.body
       }
       set (value) {
           builderResult.hasBody = true
           builderResult.body = value
       }
  }
  func clearBody() -> DBOperationReqBuilder{
       builderResult.hasBody = false
       builderResult.body = ""
       return self
  }
  var hasContenttype:Bool {
       get {
            return builderResult.hasContenttype
       }
  }
  var contenttype:String {
       get {
            return builderResult.contenttype
       }
       set (value) {
           builderResult.hasContenttype = true
           builderResult.contenttype = value
       }
  }
  func clearContenttype() -> DBOperationReqBuilder{
       builderResult.hasContenttype = false
       builderResult.contenttype = ""
       return self
  }
    var hasEnhttpmethod:Bool{
        get {
            return builderResult.hasEnhttpmethod
        }
    }
    var enhttpmethod:DBOperationReq.EnHttpMothod {
        get {
            return builderResult.enhttpmethod
        }
        set (value) {
            builderResult.hasEnhttpmethod = true
            builderResult.enhttpmethod = value
        }
    }
    func clearEnhttpmethod() -> DBOperationReqBuilder {
       builderResult.hasEnhttpmethod = false
       builderResult.enhttpmethod = .LcbHttpMethodGet
       return self
    }
    var hasEnreqtype:Bool{
        get {
            return builderResult.hasEnreqtype
        }
    }
    var enreqtype:DBOperationReq.EnReqType {
        get {
            return builderResult.enreqtype
        }
        set (value) {
            builderResult.hasEnreqtype = true
            builderResult.enreqtype = value
        }
    }
    func clearEnreqtype() -> DBOperationReqBuilder {
       builderResult.hasEnreqtype = false
       builderResult.enreqtype = .LcbHttpTypeView
       return self
    }
  var hasUuidstring:Bool {
       get {
            return builderResult.hasUuidstring
       }
  }
  var uuidstring:String {
       get {
            return builderResult.uuidstring
       }
       set (value) {
           builderResult.hasUuidstring = true
           builderResult.uuidstring = value
       }
  }
  func clearUuidstring() -> DBOperationReqBuilder{
       builderResult.hasUuidstring = false
       builderResult.uuidstring = ""
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> DBOperationReqBuilder {
    builderResult = DBOperationReq()
    return self
  }
  override func clone() -> DBOperationReqBuilder {
    return DBOperationReq.builderWithPrototype(builderResult)
  }
  override func build() -> DBOperationReq {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> DBOperationReq {
    var returnMe:DBOperationReq = builderResult
    return returnMe
  }
  func mergeFrom(other:DBOperationReq) -> DBOperationReqBuilder {
    if (other == DBOperationReq()) {
     return self
    }
    if other.hasEnlcboperation {
         enlcboperation = other.enlcboperation
    }
    if other.hasDockey {
         dockey = other.dockey
    }
    if other.hasDoctxt {
         doctxt = other.doctxt
    }
    if other.hasEnlcbstorecmd {
         enlcbstorecmd = other.enlcbstorecmd
    }
    if other.hasPath {
         path = other.path
    }
    if other.hasBody {
         body = other.body
    }
    if other.hasContenttype {
         contenttype = other.contenttype
    }
    if other.hasEnhttpmethod {
         enhttpmethod = other.enhttpmethod
    }
    if other.hasEnreqtype {
         enreqtype = other.enreqtype
    }
    if other.hasUuidstring {
         uuidstring = other.uuidstring
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->DBOperationReqBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DBOperationReqBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        var value = input.readEnum()
        var enumMergResult:EnLcbOperation = EnLcbOperation(rawValue:value)!
        if (EnLcbOperation.IsValidValue(enumMergResult)) {
             enlcboperation = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(1, value:Int64(value))
        }

      case 90 :
        dockey = input.readString()

      case 98 :
        doctxt = input.readString()

      case 104 :
        var value = input.readEnum()
        var enumMergResult:DBOperationReq.EnLcbStorageT = DBOperationReq.EnLcbStorageT(rawValue:value)!
        if (DBOperationReq.EnLcbStorageT.IsValidValue(enumMergResult)) {
             enlcbstorecmd = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(13, value:Int64(value))
        }

      case 170 :
        path = input.readString()

      case 178 :
        body = input.readString()

      case 186 :
        contenttype = input.readString()

      case 192 :
        var value = input.readEnum()
        var enumMergResult:DBOperationReq.EnHttpMothod = DBOperationReq.EnHttpMothod(rawValue:value)!
        if (DBOperationReq.EnHttpMothod.IsValidValue(enumMergResult)) {
             enhttpmethod = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(24, value:Int64(value))
        }

      case 200 :
        var value = input.readEnum()
        var enumMergResult:DBOperationReq.EnReqType = DBOperationReq.EnReqType(rawValue:value)!
        if (DBOperationReq.EnReqType.IsValidValue(enumMergResult)) {
             enreqtype = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(25, value:Int64(value))
        }

      case 802 :
        uuidstring = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class DBOperationReply : GeneratedMessage {
  private(set) var enlcboperation:EnLcbOperation = EnLcbOperation.LcbStore
  private(set) var hasEnlcboperation:Bool = false
  private(set) var hasIssuc:Bool = false
  private(set) var issuc:Bool = false

  private(set) var hasErr:Bool = false
  private(set) var err:String = ""

  private(set) var hasErrdesc:Bool = false
  private(set) var errdesc:String = ""

  private(set) var hasDockey:Bool = false
  private(set) var dockey:String = ""

  private(set) var hasDoctxt:Bool = false
  private(set) var doctxt:String = ""

  private(set) var hasHttppath:Bool = false
  private(set) var httppath:String = ""

  private(set) var hasHttpheaders:Bool = false
  private(set) var httpheaders:String = ""

  private(set) var hasHttpjsonresult:Bool = false
  private(set) var httpjsonresult:String = ""

  private(set) var hasUuidstring:Bool = false
  private(set) var uuidstring:String = ""

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasEnlcboperation {
      output.writeEnum(1, value:enlcboperation.rawValue)
    }
    if hasIssuc {
      output.writeBool(2, value:issuc)
    }
    if hasErr {
      output.writeString(3, value:err)
    }
    if hasErrdesc {
      output.writeString(4, value:errdesc)
    }
    if hasDockey {
      output.writeString(11, value:dockey)
    }
    if hasDoctxt {
      output.writeString(12, value:doctxt)
    }
    if hasHttppath {
      output.writeString(21, value:httppath)
    }
    if hasHttpheaders {
      output.writeString(22, value:httpheaders)
    }
    if hasHttpjsonresult {
      output.writeString(23, value:httpjsonresult)
    }
    if hasUuidstring {
      output.writeString(100, value:uuidstring)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if (hasEnlcboperation) {
      size += WireFormat.computeEnumSize(1, value:enlcboperation.rawValue)
    }
    if hasIssuc {
      size += WireFormat.computeBoolSize(2, value:issuc)
    }
    if hasErr {
      size += WireFormat.computeStringSize(3, value:err)
    }
    if hasErrdesc {
      size += WireFormat.computeStringSize(4, value:errdesc)
    }
    if hasDockey {
      size += WireFormat.computeStringSize(11, value:dockey)
    }
    if hasDoctxt {
      size += WireFormat.computeStringSize(12, value:doctxt)
    }
    if hasHttppath {
      size += WireFormat.computeStringSize(21, value:httppath)
    }
    if hasHttpheaders {
      size += WireFormat.computeStringSize(22, value:httpheaders)
    }
    if hasHttpjsonresult {
      size += WireFormat.computeStringSize(23, value:httpjsonresult)
    }
    if hasUuidstring {
      size += WireFormat.computeStringSize(100, value:uuidstring)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  class func parseFromData(data:[Byte]) -> DBOperationReply {
    return DBOperationReply.builder().mergeFromData(data).build()
  }
  class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> DBOperationReply {
    return DBOperationReply.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromInputStream(input:NSInputStream) -> DBOperationReply {
    return DBOperationReply.builder().mergeFromInputStream(input).build()
  }
  class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->DBOperationReply {
    return DBOperationReply.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream) -> DBOperationReply {
    return DBOperationReply.builder().mergeFromCodedInputStream(input).build()
  }
  class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DBOperationReply {
    return DBOperationReply.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  class func builder() -> DBOperationReplyBuilder {
    return DBOperationReplyBuilder()
  }
  class func builderWithPrototype(prototype:DBOperationReply) -> DBOperationReplyBuilder {
    return DBOperationReply.builder().mergeFrom(prototype)
  }
  func builder() -> DBOperationReplyBuilder {
    return DBOperationReply.builder()
  }
  func toBuilder() -> DBOperationReplyBuilder {
    return DBOperationReply.builderWithPrototype(self)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if (hasEnlcboperation) {
      output += "\(indent) enlcboperation: \(enlcboperation.rawValue)\n"
    }
    if hasIssuc {
      output += "\(indent) issuc: \(issuc) \n"
    }
    if hasErr {
      output += "\(indent) err: \(err) \n"
    }
    if hasErrdesc {
      output += "\(indent) errdesc: \(errdesc) \n"
    }
    if hasDockey {
      output += "\(indent) dockey: \(dockey) \n"
    }
    if hasDoctxt {
      output += "\(indent) doctxt: \(doctxt) \n"
    }
    if hasHttppath {
      output += "\(indent) httppath: \(httppath) \n"
    }
    if hasHttpheaders {
      output += "\(indent) httpheaders: \(httpheaders) \n"
    }
    if hasHttpjsonresult {
      output += "\(indent) httpjsonresult: \(httpjsonresult) \n"
    }
    if hasUuidstring {
      output += "\(indent) uuidstring: \(uuidstring) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasEnlcboperation {
             hashCode = (hashCode &* 31) &+ Int(enlcboperation.rawValue)
          }
          if hasIssuc {
             hashCode = (hashCode &* 31) &+ issuc.hashValue
          }
          if hasErr {
             hashCode = (hashCode &* 31) &+ err.hashValue
          }
          if hasErrdesc {
             hashCode = (hashCode &* 31) &+ errdesc.hashValue
          }
          if hasDockey {
             hashCode = (hashCode &* 31) &+ dockey.hashValue
          }
          if hasDoctxt {
             hashCode = (hashCode &* 31) &+ doctxt.hashValue
          }
          if hasHttppath {
             hashCode = (hashCode &* 31) &+ httppath.hashValue
          }
          if hasHttpheaders {
             hashCode = (hashCode &* 31) &+ httpheaders.hashValue
          }
          if hasHttpjsonresult {
             hashCode = (hashCode &* 31) &+ httpjsonresult.hashValue
          }
          if hasUuidstring {
             hashCode = (hashCode &* 31) &+ uuidstring.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "DBOperationReply"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return DBOperationReply.self
  }


  //Meta information declaration end

}

final class DBOperationReplyBuilder : GeneratedMessageBuilder {
  private var builderResult:DBOperationReply

  required override init () {
     builderResult = DBOperationReply()
     super.init()
  }
    var hasEnlcboperation:Bool{
        get {
            return builderResult.hasEnlcboperation
        }
    }
    var enlcboperation:EnLcbOperation {
        get {
            return builderResult.enlcboperation
        }
        set (value) {
            builderResult.hasEnlcboperation = true
            builderResult.enlcboperation = value
        }
    }
    func clearEnlcboperation() -> DBOperationReplyBuilder {
       builderResult.hasEnlcboperation = false
       builderResult.enlcboperation = .LcbStore
       return self
    }
  var hasIssuc:Bool {
       get {
            return builderResult.hasIssuc
       }
  }
  var issuc:Bool {
       get {
            return builderResult.issuc
       }
       set (value) {
           builderResult.hasIssuc = true
           builderResult.issuc = value
       }
  }
  func clearIssuc() -> DBOperationReplyBuilder{
       builderResult.hasIssuc = false
       builderResult.issuc = false
       return self
  }
  var hasErr:Bool {
       get {
            return builderResult.hasErr
       }
  }
  var err:String {
       get {
            return builderResult.err
       }
       set (value) {
           builderResult.hasErr = true
           builderResult.err = value
       }
  }
  func clearErr() -> DBOperationReplyBuilder{
       builderResult.hasErr = false
       builderResult.err = ""
       return self
  }
  var hasErrdesc:Bool {
       get {
            return builderResult.hasErrdesc
       }
  }
  var errdesc:String {
       get {
            return builderResult.errdesc
       }
       set (value) {
           builderResult.hasErrdesc = true
           builderResult.errdesc = value
       }
  }
  func clearErrdesc() -> DBOperationReplyBuilder{
       builderResult.hasErrdesc = false
       builderResult.errdesc = ""
       return self
  }
  var hasDockey:Bool {
       get {
            return builderResult.hasDockey
       }
  }
  var dockey:String {
       get {
            return builderResult.dockey
       }
       set (value) {
           builderResult.hasDockey = true
           builderResult.dockey = value
       }
  }
  func clearDockey() -> DBOperationReplyBuilder{
       builderResult.hasDockey = false
       builderResult.dockey = ""
       return self
  }
  var hasDoctxt:Bool {
       get {
            return builderResult.hasDoctxt
       }
  }
  var doctxt:String {
       get {
            return builderResult.doctxt
       }
       set (value) {
           builderResult.hasDoctxt = true
           builderResult.doctxt = value
       }
  }
  func clearDoctxt() -> DBOperationReplyBuilder{
       builderResult.hasDoctxt = false
       builderResult.doctxt = ""
       return self
  }
  var hasHttppath:Bool {
       get {
            return builderResult.hasHttppath
       }
  }
  var httppath:String {
       get {
            return builderResult.httppath
       }
       set (value) {
           builderResult.hasHttppath = true
           builderResult.httppath = value
       }
  }
  func clearHttppath() -> DBOperationReplyBuilder{
       builderResult.hasHttppath = false
       builderResult.httppath = ""
       return self
  }
  var hasHttpheaders:Bool {
       get {
            return builderResult.hasHttpheaders
       }
  }
  var httpheaders:String {
       get {
            return builderResult.httpheaders
       }
       set (value) {
           builderResult.hasHttpheaders = true
           builderResult.httpheaders = value
       }
  }
  func clearHttpheaders() -> DBOperationReplyBuilder{
       builderResult.hasHttpheaders = false
       builderResult.httpheaders = ""
       return self
  }
  var hasHttpjsonresult:Bool {
       get {
            return builderResult.hasHttpjsonresult
       }
  }
  var httpjsonresult:String {
       get {
            return builderResult.httpjsonresult
       }
       set (value) {
           builderResult.hasHttpjsonresult = true
           builderResult.httpjsonresult = value
       }
  }
  func clearHttpjsonresult() -> DBOperationReplyBuilder{
       builderResult.hasHttpjsonresult = false
       builderResult.httpjsonresult = ""
       return self
  }
  var hasUuidstring:Bool {
       get {
            return builderResult.hasUuidstring
       }
  }
  var uuidstring:String {
       get {
            return builderResult.uuidstring
       }
       set (value) {
           builderResult.hasUuidstring = true
           builderResult.uuidstring = value
       }
  }
  func clearUuidstring() -> DBOperationReplyBuilder{
       builderResult.hasUuidstring = false
       builderResult.uuidstring = ""
       return self
  }
  override var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  override func clear() -> DBOperationReplyBuilder {
    builderResult = DBOperationReply()
    return self
  }
  override func clone() -> DBOperationReplyBuilder {
    return DBOperationReply.builderWithPrototype(builderResult)
  }
  override func build() -> DBOperationReply {
       checkInitialized()
       return buildPartial()
  }
  func buildPartial() -> DBOperationReply {
    var returnMe:DBOperationReply = builderResult
    return returnMe
  }
  func mergeFrom(other:DBOperationReply) -> DBOperationReplyBuilder {
    if (other == DBOperationReply()) {
     return self
    }
    if other.hasEnlcboperation {
         enlcboperation = other.enlcboperation
    }
    if other.hasIssuc {
         issuc = other.issuc
    }
    if other.hasErr {
         err = other.err
    }
    if other.hasErrdesc {
         errdesc = other.errdesc
    }
    if other.hasDockey {
         dockey = other.dockey
    }
    if other.hasDoctxt {
         doctxt = other.doctxt
    }
    if other.hasHttppath {
         httppath = other.httppath
    }
    if other.hasHttpheaders {
         httpheaders = other.httpheaders
    }
    if other.hasHttpjsonresult {
         httpjsonresult = other.httpjsonresult
    }
    if other.hasUuidstring {
         uuidstring = other.uuidstring
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  override func mergeFromCodedInputStream(input:CodedInputStream) ->DBOperationReplyBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> DBOperationReplyBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        var value = input.readEnum()
        var enumMergResult:EnLcbOperation = EnLcbOperation(rawValue:value)!
        if (EnLcbOperation.IsValidValue(enumMergResult)) {
             enlcboperation = enumMergResult
        } else {
             unknownFieldsBuilder.mergeVarintField(1, value:Int64(value))
        }

      case 16 :
        issuc = input.readBool()

      case 26 :
        err = input.readString()

      case 34 :
        errdesc = input.readString()

      case 90 :
        dockey = input.readString()

      case 98 :
        doctxt = input.readString()

      case 170 :
        httppath = input.readString()

      case 178 :
        httpheaders = input.readString()

      case 186 :
        httpjsonresult = input.readString()

      case 802 :
        uuidstring = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

//Class extensions: NSData


extension DBOperationReq {
    class func parseFromNSData(data:NSData) -> DBOperationReq {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DBOperationReq.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> DBOperationReq {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DBOperationReq.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
extension DBOperationReply {
    class func parseFromNSData(data:NSData) -> DBOperationReply {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DBOperationReply.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> DBOperationReply {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return DBOperationReply.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}

// @@protoc_insertion_point(global_scope)
